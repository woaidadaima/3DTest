<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Three.jså…¨æ™¯å›¾æŸ¥çœ‹å™¨</title>
  <style>
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* æ·»åŠ ä»¥ä¸‹æ ·å¼ */
    #tag {
      display: block;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 2px 6px;
      font-weight: 700;
      font-size: 8px;
      font-family: Arial, sans-serif;
      /* user-select: none; */
      /* pointer-events: auto; */
      /* cursor: pointer; */
    }

    #lineName {
      display: block;
      color: black;
      font-weight: 700;
      font-size: 128px;
      font-family: Arial, sans-serif;
      user-select: none;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <canvas id="tag" style="width: 2048px;height: 1024px;">T1</canvas>
  <div id="lineName">å¼ ä¸°666çº¿</div>
</body>
<!-- å¼•å…¥Three.jsæ ¸å¿ƒåº“ -->
<script type="importmap">
    {
      "imports": {
        "three": "./three/build/three.module.js",
        "three/addons/": "./three/examples/jsm/",
        "@tweenjs/tween.js": "./tween.js-main/dist/tween.esm.js"
      }
    }
  </script>
<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { Sky } from "three/addons/objects/Sky.js";
  import * as TWEEN from "@tweenjs/tween.js";
  import {
    CSS3DRenderer,
    CSS3DObject,
  } from "three/addons/renderers/CSS3DRenderer.js";
  import {
    LineModel
  } from "./threeDemoJs/index.js"
  console.log(TWEEN);
  console.log("ğŸš€ ~ LineModel:", LineModel)

  // åˆå§‹åŒ–åœºæ™¯
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    80,
    window.innerWidth / window.innerHeight,
    0.1,
    20000
  );
  const canvas = document.querySelector("#c");
  const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });

  scene.background = new THREE.Color(0xC1DBFE); // æ·±è“è‰²èƒŒæ™¯


  // åˆ›å»ºå…¨æ™¯çƒä½“
  const geometry = new THREE.SphereGeometry(3000, 128, 64);
  geometry.scale(-1, 1, 1); // åè½¬çƒä½“

  //åˆ›å»ºæ ‡è®°ç‚¹
  const markerGeometry = new THREE.SphereGeometry(5, 16, 16);
  const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const markerPosition = {
    x: 326,
    y: -172,
    z: -337,
  };
  const marker = new THREE.Mesh(markerGeometry, markerMaterial);
  marker.name = "T1";
  // ç¡®ä¿æ ‡è®°ç‚¹åœ¨å…¨æ™¯çƒä½“å†…éƒ¨
  const markerPos = new THREE.Vector3(
    markerPosition.x,
    markerPosition.y,
    markerPosition.z
  );
  // markerPos.normalize().multiplyScalar(470); // ç¨å¾®é è¿‘ç›¸æœºä¸€ç‚¹
  marker.position.copy(markerPos);
  const times = [0, 1, 2];
  const values = [
    markerPos.x,
    markerPos.y,
    markerPos.z,
    markerPos.x,
    markerPos.y + 10,
    markerPos.z,
    markerPos.x,
    markerPos.y,
    markerPos.z,
  ];
  const posKF = new THREE.KeyframeTrack("T1.position", times, values);
  const clip = new THREE.AnimationClip("test", 2, [posKF]);
  const mixer = new THREE.AnimationMixer(marker);
  mixer.clipAction(clip).play();
  const clock = new THREE.Clock();

  //åˆ›å»ºæ ‡è®°ç‚¹ä¸‹æ–¹åœ†ç¯
  const markerGeometry1 = new THREE.CircleGeometry(5, 32);
  // ä¿®æ”¹æè´¨ä¸ºç™½è‰²é€æ˜
  const markerMaterial1 = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    side: THREE.DoubleSide, //ä¸¤é¢å¯è§
    // opacity: 0.8
  });
  const circle = new THREE.Mesh(markerGeometry1, markerMaterial1);
  circle.name = "circle"; // ç»™åœ†ç¯å‘½åï¼Œç”¨äºåŠ¨ç”»
  console.log("ğŸš€ ~ circle:", circle);

  // è®¡ç®—åœ†ç¯ä½ç½®ï¼Œå°†åœ†ç¯æ”¾ç½®åœ¨çº¢è‰²æ ‡è®°ç‚¹ä¸‹æ–¹10ä¸ªå•ä½
  const circlePos = markerPos.clone();
  circlePos.y -= 10; // åœ¨Yè½´æ–¹å‘ä¸‹ç§»10ä¸ªå•ä½
  circle.position.copy(circlePos);

  // è®¾ç½®åœ†ç¯çš„æ—‹è½¬ï¼Œè®©å®ƒæœå‘å±å¹•ä¸Šæ–¹ï¼ŒåŒæ—¶ä¿æŒåœ†å½¢å¯è§
  // ç»•Xè½´æ—‹è½¬-60åº¦ï¼Œè®©åœ†ç¯å€¾æ–œæœå‘ç›¸æœº
  circle.rotation.x = -Math.PI / 2; // -60åº¦
  // å¯ä»¥æ ¹æ®éœ€è¦å¾®è°ƒYè½´å’ŒZè½´çš„æ—‹è½¬
  circle.rotation.y = 0;
  circle.rotation.z = 0;

  // åˆ›å»ºåœ†ç¯çš„åŠå¾„å˜åŒ–åŠ¨ç”»
  const circleScaleTimes = [0, 1, 2];
  const circleScaleValues = [
    1,
    1,
    1, // åˆå§‹å¤§å° (scale = 1)
    4,
    4,
    4, // 1ç§’æ—¶æ”¾å¤§åˆ°2å€
    1,
    1,
    1, // 2ç§’æ—¶æ¢å¤åŸå§‹å¤§å°
  ];
  const circleScaleKF = new THREE.KeyframeTrack(
    "circle.scale",
    circleScaleTimes,
    circleScaleValues
  );
  const circleClip = new THREE.AnimationClip("circleScale", 2, [
    circleScaleKF,
  ]);
  const circleMixer = new THREE.AnimationMixer(circle);
  circleMixer.clipAction(circleClip).play();

  //åˆ›å»ºä¸€æ¡æ›²çº¿
  const pointArr = [
    new THREE.Vector3(-1128, 414, -2748),
    new THREE.Vector3(570, 445, -2911),
    new THREE.Vector3(1868, 376, -2314),
  ];
  //åˆ›å»ºçº¿åç§°
  const lineNameLabel = document.getElementById("lineName");
  console.log("ğŸš€ ~ lineNameLabel:", lineNameLabel.style)
  // HTMLå…ƒç´ è½¬åŒ–ä¸ºthreejsçš„CSS2æ¨¡å‹å¯¹è±¡
  const lineNameTag = new CSS3DObject(lineNameLabel);
  lineNameTag.position.set(pointArr[1].x, pointArr[1].y, pointArr[1].z);
  const css3Renderer = new CSS3DRenderer();
  css3Renderer.setSize(window.innerWidth, window.innerHeight); // è®¾ç½®CSS2Dæ¸²æŸ“å™¨å°ºå¯¸

  css3Renderer.domElement.style.position = "absolute";
  css3Renderer.domElement.style.top = "0px";
  css3Renderer.domElement.style.pointerEvents = "none"; // é˜²æ­¢æ ‡ç­¾æ‹¦æˆªé¼ æ ‡
  const lineInstance = new LineModel({
    basicMaterial: {
      color: "#00FF41", // æ›´é²œè‰³çš„ç»¿è‰²
      linewidth: "100", // å¢åŠ çº¿æ¡ç²—ç»†
      transparent: true,
      opacity: 0.9
    },
    dataSource: [
      [- 1128, 414, -2748],
      [- 570, 445, - 2911],
      [- 1868, 376, - 2314],
    ]
  }, {
    domId: 'lineName',
    window: window
  })


  console.log("ğŸš€ ~ lineInstance:", lineInstance.line)
  const curve = new THREE.CatmullRomCurve3(pointArr);
  const pointsArr = curve.getPoints(600);
  const geometryLine = new THREE.BufferGeometry();
  //è¯»å–åæ ‡æ•°æ®èµ‹å€¼ç»™å‡ ä½•ä½“é¡¶ç‚¹
  geometryLine.setFromPoints(pointsArr);
  // çº¿æè´¨ - ä½¿ç”¨æ›´é²œè‰³çš„é¢œè‰²å’Œæ›´ç²—çš„çº¿æ¡
  const material = new THREE.LineBasicMaterial({
    color: "#00FF41", // æ›´é²œè‰³çš„ç»¿è‰²
    linewidth: "100", // å¢åŠ çº¿æ¡ç²—ç»†
    transparent: true,
    opacity: 0.9, // ç¨å¾®é€æ˜ä»¥å¢å¼ºè§†è§‰æ•ˆæœ
  });
  // çº¿æ¨¡å‹
  const line = new THREE.Line(geometryLine, material);
  console.log("ğŸš€ ~ line:", line)
  const linesGroup = new THREE.Group();
  linesGroup.add(line, lineNameTag);

  //åˆ›å»ºæ ‡ç­¾
  const div = document.getElementById("tag");

  //è·å–canvasä¸Šä¸‹æ–‡
  const context = div.getContext("2d");
  const pixelRatio = window.devicePixelRatio || 1; // è·å–è®¾å¤‡åƒç´ æ¯”
  const width = 256; // é€»è¾‘å®½åº¦
  const height = 128; // é€»è¾‘é«˜åº¦

  div.width = width * pixelRatio; // å®é™…åƒç´ å®½åº¦
  div.height = height * pixelRatio; // å®é™…åƒç´ é«˜åº¦
  div.style.width = `${width}px`; // æ˜¾ç¤ºå®½åº¦ï¼ˆCSSåƒç´ ï¼‰
  div.style.height = `${height}px`; // æ˜¾ç¤ºé«˜åº¦
  // 2. ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é…é«˜æ¸… Canvas
  context.scale(pixelRatio, pixelRatio);

  context.fillStyle = "rgba(0, 0, 0, 0.5)";
  context.fillRect(0, 0, width, height);
  context.font = "bold 90px Arial";
  context.fillStyle = "white";
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.fillText("T1", width / 2, height / 2);

  // 2. è½¬æ¢ä¸º Three.js çº¹ç†å¹¶åˆ›å»º Sprite
  const texture = new THREE.CanvasTexture(div);
  texture.minFilter = THREE.LinearFilter; // ç¼©å°è¿‡æ»¤
  texture.magFilter = THREE.LinearFilter; // æ”¾å¤§è¿‡æ»¤
  texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // å„å‘å¼‚æ€§è¿‡æ»¤
  const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(40, 20, 5);
  sprite.position.copy(markerPos).add(new THREE.Vector3(0, 30, 0));

  // tag.position.copy(markerPos).add(new THREE.Vector3(0, 30, 0));



  const marksGroup = new THREE.Group();
  marksGroup.add(marker, circle, sprite);
  // group.add(circle);
  // group.add(tag);
  console.log("ğŸš€ ~ marksGroup:", marksGroup);

  document.body.appendChild(css3Renderer.domElement);

  windowResize(); // åˆå§‹åŒ–å°ºå¯¸
  // åŠ è½½çº¹ç†
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load(
    "./images/DJI_20250228152043_0001_V.JPG",
    function (texture) {
      console.log(
        "Loaded texture size:",
        texture.image.width,
        texture.image.height
      );
      texture.colorSpace = THREE.SRGBColorSpace; // å…³é”®ï¼å‘Šè¯‰Three.jsè¿™æ˜¯sRGBè‰²å½©
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // å„å‘å¼‚æ€§è¿‡æ»¤
      texture.minFilter = THREE.LinearFilter; // ç¦ç”¨é»˜è®¤çš„mipmapå‹ç¼©
      texture.magFilter = THREE.LinearFilter; // ç¦ç”¨æ”¾å¤§æ—¶çš„æ¨¡ç³Š
      texture.generateMipmaps = false; // å…³é—­mipmapç”Ÿæˆï¼ˆé¿å…é™çº§ï¼‰
      const material = new THREE.MeshBasicMaterial({ map: texture });
      const sphere = new THREE.Mesh(geometry, material);
      sphereMesh = sphere; // ä¿å­˜çƒä½“å¼•ç”¨
      scene.add(sphere);
      scene.add(linesGroup);
      scene.add(marksGroup);

    }
  );
  camera.position.set(6000, 6000, 6000);
  camera.lookAt(0, 0, 0);
  // è§†è§‰æ•ˆæœï¼šåœ°çƒä»å°åˆ°å¤§å‡ºç°(é€è§†æŠ•å½±ç›¸æœºè¿œå°è¿‘å¤§æŠ•å½±è§„å¾‹)
  let tween2 = new TWEEN.Tween(camera.position)

    .to({ x: 0, y: 0, z: 100 }, 6000)
    .onUpdate(() => {
      camera.lookAt(0, 0, 0);
    })
    .easing(TWEEN.Easing.Quadratic.Out)
    .start()

  // camera.position.z = 100;

  // åˆå§‹åŒ–å…‰çº¿æŠ•å°„å™¨ï¼ˆç”¨äºè®¡ç®—ç‚¹å‡»ä½ç½®ï¼‰
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let tween = null;

  // åœºæ™¯çŠ¶æ€ç®¡ç†
  let currentScene = 'scene1'; // å½“å‰åœºæ™¯ï¼šscene1 æˆ– scene2
  let sphereMesh = null; // å…¨æ™¯çƒä½“å¼•ç”¨

  // åˆ›å»ºåœºæ™¯2çš„æ ‡è®°ç‚¹T2
  const createT2Marker = () => {
    // T2æ ‡è®°ç‚¹
    const t2MarkerGeometry = new THREE.SphereGeometry(5, 16, 16);
    const t2MarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // ç»¿è‰²
    const t2Marker = new THREE.Mesh(t2MarkerGeometry, t2MarkerMaterial);
    t2Marker.name = "T2";

    // T2æ ‡è®°ç‚¹ä½ç½®
    const t2MarkerPosition = {
      x: -200,
      y: 50,
      z: 400,
    };
    const t2MarkerPos = new THREE.Vector3(
      t2MarkerPosition.x,
      t2MarkerPosition.y,
      t2MarkerPosition.z
    );
    t2MarkerPos.normalize().multiplyScalar(470);
    t2Marker.position.copy(t2MarkerPos);

    // T2åœ†ç¯
    const t2CircleGeometry = new THREE.CircleGeometry(5, 32);
    const t2CircleMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      side: THREE.DoubleSide,
    });
    const t2Circle = new THREE.Mesh(t2CircleGeometry, t2CircleMaterial);
    t2Circle.name = "t2Circle";

    const t2CirclePos = t2MarkerPos.clone();
    t2CirclePos.y -= 10;
    t2Circle.position.copy(t2CirclePos);
    t2Circle.rotation.x = -Math.PI / 2;

    // T2æ ‡ç­¾
    const t2Canvas = document.createElement('canvas');
    const t2Context = t2Canvas.getContext('2d');
    const pixelRatio = window.devicePixelRatio || 1;
    const width = 256;
    const height = 128;

    t2Canvas.width = width * pixelRatio;
    t2Canvas.height = height * pixelRatio;
    t2Canvas.style.width = `${width}px`;
    t2Canvas.style.height = `${height}px`;
    t2Context.scale(pixelRatio, pixelRatio);

    t2Context.fillStyle = "rgba(0, 128, 0, 0.5)";
    t2Context.fillRect(0, 0, width, height);
    t2Context.font = "bold 90px Arial";
    t2Context.fillStyle = "white";
    t2Context.textAlign = "center";
    t2Context.textBaseline = "middle";
    t2Context.fillText("T2", width / 2, height / 2);

    const t2Texture = new THREE.CanvasTexture(t2Canvas);
    t2Texture.minFilter = THREE.LinearFilter;
    t2Texture.magFilter = THREE.LinearFilter;
    t2Texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    const t2SpriteMaterial = new THREE.SpriteMaterial({ map: t2Texture });
    const t2Sprite = new THREE.Sprite(t2SpriteMaterial);
    t2Sprite.scale.set(40, 20, 5);
    t2Sprite.position.copy(t2MarkerPos).add(new THREE.Vector3(0, 30, 0));

    // T2æ ‡è®°ç‚¹åŠ¨ç”»
    const t2Times = [0, 1, 2];
    const t2Values = [
      t2MarkerPos.x,
      t2MarkerPos.y,
      t2MarkerPos.z,
      t2MarkerPos.x,
      t2MarkerPos.y + 10,
      t2MarkerPos.z,
      t2MarkerPos.x,
      t2MarkerPos.y,
      t2MarkerPos.z,
    ];
    const t2PosKF = new THREE.KeyframeTrack("T2.position", t2Times, t2Values);
    const t2Clip = new THREE.AnimationClip("t2Test", 2, [t2PosKF]);
    const t2Mixer = new THREE.AnimationMixer(t2Marker);
    t2Mixer.clipAction(t2Clip).play();

    // T2åœ†ç¯ç¼©æ”¾åŠ¨ç”»
    const t2CircleScaleTimes = [0, 1, 2];
    const t2CircleScaleValues = [
      1, 1, 1, // åˆå§‹å¤§å°
      4, 4, 4, // 1ç§’æ—¶æ”¾å¤§åˆ°4å€
      1, 1, 1, // 2ç§’æ—¶æ¢å¤åŸå§‹å¤§å°
    ];
    const t2CircleScaleKF = new THREE.KeyframeTrack(
      "t2Circle.scale",
      t2CircleScaleTimes,
      t2CircleScaleValues
    );
    const t2CircleClip = new THREE.AnimationClip("t2CircleScale", 2, [
      t2CircleScaleKF,
    ]);
    const t2CircleMixer = new THREE.AnimationMixer(t2Circle);
    t2CircleMixer.clipAction(t2CircleClip).play();

    const t2Group = new THREE.Group();
    t2Group.add(t2Marker, t2Circle, t2Sprite);
    // å°†åŠ¨ç”»æ··åˆå™¨æ·»åŠ åˆ°ç»„çš„userDataä¸­ï¼Œä»¥ä¾¿åœ¨åŠ¨ç”»å¾ªç¯ä¸­æ›´æ–°
    t2Group.userData = {
      markerMixer: t2Mixer,
      circleMixer: t2CircleMixer
    };
    return t2Group;
  };

  // åœºæ™¯çŠ¶æ€å®šä¹‰
  const sceneStates = {
    scene1: {
      texture: "./images/DJI_20250228152043_0001_V.JPG",
      markers: marksGroup, // T1æ ‡è®°ç»„
      lines: linesGroup,
      css3D: true
    },
    scene2: {
      texture: "./images/HMSHå…¨æ™¯_00635_.png",
      markers: createT2Marker(), // T2æ ‡è®°ç»„
      lines: null,
      css3D: false
    }
  };

  // åˆ‡æ¢åœºæ™¯å‡½æ•°
  const switchToScene = (targetScene) => {
    if (currentScene === targetScene) return;

    const currentState = sceneStates[currentScene];
    const targetState = sceneStates[targetScene];

    // ç§»é™¤å½“å‰åœºæ™¯çš„å…ƒç´ 
    if (currentState.markers) scene.remove(currentState.markers);
    if (currentState.lines) scene.remove(currentState.lines);
    if (currentState.css3D && css3Renderer.domElement.parentNode) {
      css3Renderer.domElement.parentNode.removeChild(css3Renderer.domElement);
    }

    // åŠ è½½æ–°åœºæ™¯çš„çº¹ç†
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(targetState.texture, function (newTexture) {
      console.log(`Loading ${targetScene} panorama texture...`);
      newTexture.colorSpace = THREE.SRGBColorSpace;
      newTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      newTexture.minFilter = THREE.LinearFilter;
      newTexture.magFilter = THREE.LinearFilter;
      newTexture.generateMipmaps = false;

      // æ›´æ–°çƒä½“çº¹ç†
      if (sphereMesh) {
        sphereMesh.material.map = newTexture;
        sphereMesh.material.needsUpdate = true;
      }

      // æ·»åŠ æ–°åœºæ™¯çš„å…ƒç´ 
      if (targetState.markers) scene.add(targetState.markers);
      if (targetState.lines) scene.add(targetState.lines);
      if (targetState.css3D) {
        document.body.appendChild(css3Renderer.domElement);
      }

      currentScene = targetScene;
      console.log(`Switched to ${targetScene} successfully!`);
    });
  };

  // ç»Ÿä¸€çš„ç‚¹å‡»äº‹ä»¶å¤„ç†
  window.addEventListener("click", (event) => {
    // è·å–é¼ æ ‡æ ‡å‡†åŒ–åæ ‡
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // æ›´æ–°å°„çº¿æŠ•å°„å™¨
    raycaster.setFromCamera(mouse, camera);

    // æ£€æµ‹å½“å‰åœºæ™¯çš„æ ‡è®°ç‚¹
    const currentMarkers = sceneStates[currentScene].markers;
    if (!currentMarkers) return;

    const intersects = raycaster.intersectObjects([currentMarkers]);
    console.log("ğŸš€ ~ click intersects:", intersects);

    if (intersects.length > 0) {
      // æ ¹æ®å½“å‰åœºæ™¯åˆ‡æ¢åˆ°å¦ä¸€ä¸ªåœºæ™¯
      const targetScene = currentScene === 'scene1' ? 'scene2' : 'scene1';
      switchToScene(targetScene);
    }
  });

  //ç›‘å¬é¼ æ ‡ç§»å…¥äº‹ä»¶
  window.addEventListener("mousemove", (event) => {
    // è·å–é¼ æ ‡æ ‡å‡†åŒ–åæ ‡
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // æ›´æ–°å°„çº¿æŠ•å°„å™¨
    raycaster.setFromCamera(mouse, camera);

    // æ£€æµ‹å½“å‰åœºæ™¯çš„æ ‡è®°ç‚¹
    const currentMarkers = sceneStates[currentScene].markers;
    if (!currentMarkers) {
      renderer.domElement.style.cursor = "auto";
      return;
    }

    const intersects = raycaster.intersectObjects([currentMarkers]);
    // æ”¹å˜é¼ æ ‡æ ·å¼
    renderer.domElement.style.cursor =
      intersects.length > 0 ? "pointer" : "auto";
  });
  // æ·»åŠ è½¨é“æ§åˆ¶å™¨
  const controls = new OrbitControls(camera, renderer.domElement);

  controls.mouseButtons = {
    LEFT: THREE.MOUSE.ROTATE,
    MIDDLE: THREE.MOUSE.DOLLY,
    RIGHT: THREE.MOUSE.PAN,
  };

  controls.enableZoom = true; // å¯ç”¨ç¼©æ”¾
  controls.zoomSpeed = 1.5;
  controls.enablePan = false; // ç¦ç”¨å¹³ç§»
  controls.minDistance = 0.5; // æœ€å°ç¼©æ”¾è·ç¦»
  controls.maxDistance = 1500; // æœ€å¤§ç¼©æ”¾è·ç¦»
  // é™åˆ¶ä¿¯ä»°è§’åº¦ï¼Œé˜²æ­¢çœ‹åˆ°æç‚¹
  controls.minPolarAngle = Math.PI / 8;
  controls.maxPolarAngle = Math.PI - Math.PI / 8;

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;

    const width = canvas.clientWidth * window.devicePixelRatio;

    const height = canvas.clientHeight * window.devicePixelRatio;


    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  // åŠ¨ç”»å¾ªç¯
  function animate() {
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      css3Renderer.setSize(canvas.clientWidth, canvas.clientHeight); // åŒæ­¥ CSS2D å°ºå¯¸
    }
    tween2.update();
    if (tween) {
      tween.update();
    }
    // controls.update(); // æ›´æ–°æ§åˆ¶å™¨
    renderer.render(scene, camera);

    css3Renderer.render(scene, camera); // æ¸²æŸ“ CSS2D æ ‡ç­¾

    requestAnimationFrame(animate);



    const frameT = clock.getDelta();
    // æ›´æ–°T1æ ‡è®°ç‚¹åŠ¨ç”»
    mixer.update(frameT);
    circleMixer.update(frameT);

    // æ›´æ–°T2æ ‡è®°ç‚¹åŠ¨ç”»ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const t2Markers = sceneStates.scene2.markers;
    if (t2Markers && t2Markers.userData) {
      if (t2Markers.userData.markerMixer) {
        t2Markers.userData.markerMixer.update(frameT);
      }
      if (t2Markers.userData.circleMixer) {
        t2Markers.userData.circleMixer.update(frameT);
      }
    }
  }
  animate();

  function windowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    css3Renderer.setSize(window.innerWidth, window.innerHeight); // åŒæ­¥CSS2Dæ¸²æŸ“å™¨å°ºå¯¸
  }
  // å“åº”å¼è°ƒæ•´
  window.addEventListener("resize", windowResize);
</script>

</html>